[
  {
    "objectID": "2024-cmb-france-6/index.html#furax-library",
    "href": "2024-cmb-france-6/index.html#furax-library",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Library",
    "text": "FURAX Library\n \n\n\n\nMotivations and Goals: Why and for what FURAX ?  \nFURAX Bulding Blocks: Presentation of the FURAX PyTrees and Operators.  \nOptimizations: High-level algebraic reductions with FURAX.  \nCMB Applications: From map-making to component separation."
  },
  {
    "objectID": "2024-cmb-france-6/index.html#motivations-and-goals",
    "href": "2024-cmb-france-6/index.html#motivations-and-goals",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Motivations and Goals",
    "text": "Motivations and Goals\n\nInverse problems\nOpen source: https://github.com/CMBSciPol/furax\n\n\n\nModularity, extensibility, simplicity: Easy to experiment new ideas, Fail fast approach\nJAX: Differentiation, Just In Time (JIT) compilation, run the same code anywhere — on CPUs and GPUs, laptops and super-computers\nFramework for robust B-mode analysis\nAble to handle SO- and S4-like data sets volumes, Compatibility with TOAST\nNon-ideal optical components\n1st steps: “max-L” and “template” map-making (following MAPPRAISER’s formalism)\nMulti-GPU parallelization (soon)\n\nYou can try it: pip install furax, bearing in mind that the library is actively developed and currently in a refactoring phase."
  },
  {
    "objectID": "2024-cmb-france-6/index.html#furax-pytrees",
    "href": "2024-cmb-france-6/index.html#furax-pytrees",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX PyTrees",
    "text": "FURAX PyTrees\n \nFURAX relies on PyTrees to represent the data. For example, for component separation analysis, we can write the generalized sky as a nested PyTree\nsky = {\n  'cmb': HealpixLandscape(NSIDE, 'IQU').normal(key1),\n  'dust': HealpixLandscape(NSIDE, 'IQU').normal(key2),\n  'synchrotron': HealpixLandscape(NSIDE, 'IQU').normal(key3),\n}\nHealpixLandscape(NSIDE, 'IQU') returns an instance of StokesIQUPyTree, which has the attributes i, q and u that store the JAX arrays of the Stokes components.\nAlso available are StokesIPyTree, StokesQUPyTree and StokesIQUVPyTree.\n\nPyTree are then used by the FURAX Operators:\n# Given an acquisition H:\ntod = H(sky)"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#furax-operators",
    "href": "2024-cmb-france-6/index.html#furax-operators",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Operators",
    "text": "FURAX Operators\n\nThe base class AbstractLinearOperator provides a default implementation for the usual linear algebra operations.\n\n\n\n\n\n\n\n\n\n\nOperation\nFURAX\nComment\n\n\n\n\nAddition\nA + B\n\n\n\nComposition\nA @ B\n\n\n\nMultiplication by scalar\nk * A\nReturns the composition of a HomothetyOperator and A\n\n\nTranspose\nA.T\nThrough JAX autodiff, but can be overriden\n\n\nInverse\nA.I\nBy default, the CG solver is used, but it can be overriden or configured using a context manager\n\n\nBlock Assembly\nBlockColumnOperator([A, B]) BlockDiagonalOperator([A, B]) BlockRowOperator([A, B])\nHandle any PyTree of Operators: Block*Operator({'a': A, 'b': B})\n\n\nFlattened dense matrix\nA.as_matrix()\n\n\n\nAlgebraic reduction\nA.reduce()"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#furax-operators-1",
    "href": "2024-cmb-france-6/index.html#furax-operators-1",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Operators",
    "text": "FURAX Operators\n \n\n\n\n\n\n\n\n\n\n\n\nGeneric Operator\nDescription\n\n\n\n\nIdentityOperator\n\n\n\nHomothetyOperator\n\n\n\nDiagonalOperator\n\n\n\nBroadcastDiagonalOperator\nNon-square operator for broadcasting\n\n\nTensorOperator\nFor dense matrix operations\n\n\nIndexOperator\nCan be used for projecting skies onto time-ordered series\n\n\nMoveAxisOperator\n\n\n\nReshapeOperator\n\n\n\nRavelOperator\n\n\n\nSymmetricBandToeplitzOperator\nMethods: direct, FFT, overlap and save\n\n\nBlock*Operator\nBlock assembly operators (column, diagonal, row)\n\n\n\n\n\n\n\n\n\n\n\nApplied Operator\nDescription\n\n\n\n\nQURotationOperator\n\n\n\nHWPOperator\nIdeal HWP\n\n\nLinearPolarizerOperator\nIdeal linear polarizer\n\n\nCMBOperator\nParametrized CMB SED\n\n\nDustOperator\nParametrized dust SED\n\n\nSynchrotronOperator\nParametrized synchrotron SED"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#jax-gpu-compilation-chain",
    "href": "2024-cmb-france-6/index.html#jax-gpu-compilation-chain",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "JAX GPU Compilation Chain",
    "text": "JAX GPU Compilation Chain\n    \n\nFrom the Python code to the GPU-native code"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#xla-simplifications",
    "href": "2024-cmb-france-6/index.html#xla-simplifications",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "XLA simplifications",
    "text": "XLA simplifications\n\n\n\n\n\nMathematical identities\n\n\n\n\\(a\\times 0 = a - a = 0\\)\n\\(a - 0 = a\\times 1 = a / 1 = a^1 = a\\)\n\\(a^{-1} = 1/a\\), \\(a^{1/2} = \\sqrt{a}\\)\n\\(-(-x) = x\\)\n\\((-a)(-b) = ab\\)\n\\(ac + bc = (a+b)c\\)\n\\(a / const = a \\times (1 / const)\\)\n\\((a + c1) + (b + c2) =  a + b + (c1 + c2)\\)\n\\((a / b) / (c / d) = ad / bc\\)\n\\(\\ln e^x = x\\)\n\\(\\exp a \\exp b = \\exp(a+b)\\)\n\\(a / \\exp b = a \\exp(-b)\\)\n\n\n\n\n\n\nArray manipulations\n\n\n\nslicing\nreshaping\nbroadcasting\ntransposition\nbitcast\ncopies\n\n\n\n\n\nOl’ Digger’s tricks\n\n\n\n\\(a^2 = a \\times a\\), \\(a^3 = a \\times a \\times a\\)\n\\(a / b = a\\)&gt;&gt;\\(\\log_2 b\\) if b is a power of 2\n\\(a \\mod b = a \\& (b - 1)\\) if b is a power of 2\n\n\n\n\nand many more (see xla/hlo/transforms/simplifiers/algebraic_simplifier.cc)"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#dead-code-elimination-dce",
    "href": "2024-cmb-france-6/index.html#dead-code-elimination-dce",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Dead Code Elimination (DCE)",
    "text": "Dead Code Elimination (DCE)\n\n\nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef func_dce(x):\n    unused = jnp.sin(x)\n    y = jnp.exp(x)\n    return y[0]\n\n\n\n\nCompiled StableHLO representation\n\n\n\n\n\nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef func_full(x):\n    return jnp.exp(x)\n\n\n\n\n\n\n\nFull computation vs DCE"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#xla-common-subexpression-elimination-cse",
    "href": "2024-cmb-france-6/index.html#xla-common-subexpression-elimination-cse",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "XLA Common Subexpression Elimination (CSE)",
    "text": "XLA Common Subexpression Elimination (CSE)\n\n\nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef func_cse(theta):\n    a = jnp.sin(theta)\n    b = jnp.sin(theta) + 1\n    return a + b\n\n\n\nXLA Common Subexpression Elimination (CSE)\n\n\n\nDefinition: CSE identifies and eliminates duplicate computations within a function to optimize performance.\nExample in Code:\n\nWithout CSE: jnp.sin(theta) computed twice.\nAfter CSE: Shared computation across a and b.\n\nBenefits:\n\nReduces redundant computation.\nEnhances runtime efficiency and memory usage.\n\n\n\n\n\n\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#jax-gpu-compilation-chain-with-furax",
    "href": "2024-cmb-france-6/index.html#jax-gpu-compilation-chain-with-furax",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "JAX GPU Compilation Chain with FURAX",
    "text": "JAX GPU Compilation Chain with FURAX\n    \n\nFrom the Python code to the GPU-native code"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#furax-algebraic-reductions-composition-of-rotations",
    "href": "2024-cmb-france-6/index.html#furax-algebraic-reductions-composition-of-rotations",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Composition of Rotations",
    "text": "FURAX Algebraic Reductions: Composition of Rotations\nimport jax\nimport jax.numpy as jnp\n\ndef rot(x, y, theta):\n    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)\n    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)\n    return rotated_x, rotated_y\n\n@jax.jit\ndef func(x, y, theta1, theta2):\n    return rot(x, y, theta=theta1 + theta2)\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#furax-algebraic-reductions-composition-of-rotations-1",
    "href": "2024-cmb-france-6/index.html#furax-algebraic-reductions-composition-of-rotations-1",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Composition of Rotations",
    "text": "FURAX Algebraic Reductions: Composition of Rotations\nimport jax\nimport jax.numpy as jnp\n\ndef rot(x, y, theta):\n    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)\n    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)\n    return rotated_x, rotated_y\n\n@jax.jit\ndef func(x, y, theta1, theta2):\n    x, y = rot(x, y, theta=theta1)\n    return rot(x, y, theta=theta2)\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#furax-algebraic-reductions-instrument-acquisition",
    "href": "2024-cmb-france-6/index.html#furax-algebraic-reductions-instrument-acquisition",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Instrument Acquisition",
    "text": "FURAX Algebraic Reductions: Instrument Acquisition\n\nGiven this modeling of the acquisition, using an ideal linear polarizer and an ideal half wave plate: \\[\n\\mathbf{H} = \\mathbf{C}_{\\textrm{LP}} \\, \\mathbf{R}_{2\\theta} \\, \\mathbf{R}_{-2\\phi} \\, \\mathbf{C}_{\\textrm{HWP}} \\, \\mathbf{R}_{2\\phi} \\, \\mathbf{R}_{2\\psi} \\, \\mathbf{P}\n\\] with\n\n\\(\\theta\\): detector polarization angle\n\\(\\phi\\): HWP rotation angle\n\\(\\psi\\): telescope rotation angle\n\nFURAX reduces this expression to:\n\\[\n\\mathbf{H} = \\mathbf{C}_{\\textrm{LP}} \\, \\mathbf{R}_{-2\\theta + 4\\phi + 2\\psi}\\, \\mathbf{P}\n\\]"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#furax-algebraic-reductions-pointing-matrix",
    "href": "2024-cmb-france-6/index.html#furax-algebraic-reductions-pointing-matrix",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Pointing Matrix",
    "text": "FURAX Algebraic Reductions: Pointing Matrix\n\n\nWhen the time-time noise covariance matrix \\(\\mathbf{N}\\) is diagonal and \\(\\mathbf{P}\\) is a “one-to-one” intensity projection matrix:\n\\[\n\\mathbf{P} =\n\\begin{bmatrix}\n0 & \\cdots & 0 & 1 & 0 & \\cdots & 0 \\\\\n0 & 1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n0 & 0 & \\cdots & 0 & 1 & 0 & \\cdots & 0 \\\\\n\\end{bmatrix},\n\\]\n \n\nthe product \\(\\mathbf{P}^\\top \\mathbf{N}^{-1} \\mathbf{P}\\) is diagonal and can therefore be easily inverted (for pixel-pixel covariance matrix or preconditioning).\nEach term is related to the number of noise-weighted times a pixel of the map has been observed.\nFor IQU maps, the product is block diagonal, with 3x3 blocks that can also be easily inverted.\nBy adding a rule for this operation, we’ve seen an performance improvement by more than a factor of 10 in the forward application (WIP, currently only for \\(\\mathbf{N}\\) scalar)."
  },
  {
    "objectID": "2024-cmb-france-6/index.html#furax-algebraic-reductions-block-assembly",
    "href": "2024-cmb-france-6/index.html#furax-algebraic-reductions-block-assembly",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Block Assembly",
    "text": "FURAX Algebraic Reductions: Block Assembly\n\n \n\n\n\n\n\n\n\nOperation\nReduction\n\n\n\n\nBlockDiagonalOperator([D1, D2]) @ BlockColumnOperator([C1, C2])\nBlockColumnOperator([D1 @ C1, D2 @ C2])\n\n\nBlockRowOperator([R1, R2]) @ BlockDiagonalOperator([D1, D2])\nBlockRowOperator([R1 @ D1, R2 @ D2])\n\n\nBlockRowOperator([R1, R2]) @ BlockColumnOperator([C1, C2])\nR1 @ C1 + R2 @ C2\n\n\n\n\n \nPractical use case:\nGiven two observations\n\\[\n\\mathbf{P} =\n\\begin{bmatrix}\n\\mathbf{P}_1 \\\\\n\\mathbf{P}_2\n\\end{bmatrix}, \\quad\n\\mathbf{N}^{-1} =\n\\begin{bmatrix}\n\\mathbf{N}_1^{-1} & 0 \\\\\n0 & \\mathbf{N}_2^{-1}\n\\end{bmatrix},\n\\]\nThe combination is reduced to \\[\n\\mathbf{P}^\\top \\mathbf{N}^{-1} \\mathbf{P} = \\mathbf{P}_1^\\top \\mathbf{N}_1^{-1} \\mathbf{P}_1^{\\,} + \\mathbf{P}_2^\\top \\mathbf{N}_2^{-1} \\mathbf{P}_2^{\\,}.\n\\]"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#maximum-likelihood-map-making",
    "href": "2024-cmb-france-6/index.html#maximum-likelihood-map-making",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Maximum-Likelihood Map-Making",
    "text": "Maximum-Likelihood Map-Making\n\n\n\nClassic data model\n\\[\nd = \\mathbf{P}s + n\n\\]\n\n\\(d\\): time-ordered data\n\\(\\mathbf{P}\\): pointing matrix ( telescope scanning)\n\\(s\\): discretized sky signal\n\\(n\\): stochastic contribution (noise)\n\n\nOptimal (GLS) solution:\n\\[\n\\widehat{s} = (\\mathbf{P}^\\top \\mathbf{N}^{-1} \\mathbf{P})^{-1} \\mathbf{P}^\\top \\mathbf{N}^{-1} d\n\\]\n\nGeneralized parametric data model\n\n\n\n\n\n\\[\nd_{\\nu, i, t} = \\int_{\\textrm{BP}_\\nu} d\\nu' \\mathbf{M}^{(\\gamma)}_{\\nu', i, t, p} \\mathbf{A}^{(\\beta)}_{\\nu', t, c, p} s_{c, p} + n_{\\nu, i, t}\n\\]\n\n\\(\\mathbf{M}\\) includes HWP parameters, band passes, beam properties, gains, …\n\\(\\mathbf{A}\\) includes the frequency modeling of CMB, astrophysical foregrounds, atmosphere, ground\n\\(\\mathbf{H} = \\mathbf{MA}\\) is the generalized pointing operator\n\n\n\nCredit: Simon Biquart"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#maximum-likelihood-map-making-1",
    "href": "2024-cmb-france-6/index.html#maximum-likelihood-map-making-1",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Maximum-Likelihood Map-Making",
    "text": "Maximum-Likelihood Map-Making\n\n\n\n\n\n\n\\(N^{-1}\\) Block symmetric band Toeplitz\n\n\n\n\n\n\n\n\n\nFurax example\nh = bandpass @ pol @ rot @ hwp @ proj @ mixing\ntod = h(sky)\nsolution = ((h.T @ invN @ h).I @ h.T @ invN)(gap_fill(key, tod))\n\nCredit: Simon Biquart"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#writing-this-with-furax-tools",
    "href": "2024-cmb-france-6/index.html#writing-this-with-furax-tools",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Writing this with FURAX tools",
    "text": "Writing this with FURAX tools\n\n\n\npolarizer = LinearPolarizerOperator.create(detector_angles)\nhwp = HWPOperator.create(hwp_angles)\nrotation = QURotationOperator.create(telescope_angle)\nsampling = SamplingOperator(pixel_indices)\nh = polarizer @ hwp @ rotation @ sampling\ninvN = SymmetricBandToeplitzOperator(noise_correlations)\nL = (h.T @ invN @ h).I @ h.T @ invN\nestimate = L(data)\n  \n\n\nFURAX Map-Making\n\n\nCan be extended & complexified easily!. - non-ideal components - parametric data model\n\n\n\nCredit: Simon Biquart"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#quantifying-biases-from-non-ideal-half-wave-plates",
    "href": "2024-cmb-france-6/index.html#quantifying-biases-from-non-ideal-half-wave-plates",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Quantifying Biases from Non-Ideal Half Wave Plates",
    "text": "Quantifying Biases from Non-Ideal Half Wave Plates\n\n\nNon-ideal Half Wave Plate\n\nMade of several stacked layers\nTakes into account the transmission and reflection of the incident electromagnetic field at the layers boundaries\n\nFurax modeling\nh = pol @ bandpass @ hwp @ mixing_matrix @ projection\nsol = ((h.T @ h).I @ h.T)(tod)\n\nCredit: Ema Tsang King Sang"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#component-separation",
    "href": "2024-cmb-france-6/index.html#component-separation",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Component Separation",
    "text": "Component Separation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Cosmic Microwave Background (CMB) signal is obscured by various foregrounds, making it challenging to detect the true cosmological information.\n\n\n\nDust: Emission from galactic dust adds significant noise to the CMB, particularly affecting polarization measurements.\n\n\n\n\nSynchrotron Radiation: Electrons spiraling in the galaxy’s magnetic fields produce synchrotron radiation, another major contaminant.\n\n\n\n\n\nComponent separation methods\n\n\n\nBlind Methods: Like SMICA (Spectral Matching Independent Component Analysis)\nParametric Methods: Like FGbuster (Foreground Buster)\n\n\n\n\n\n\nLe signal du fond diffus cosmologique, ou CMB, est en réalité obscurci par plusieurs avant-plans, ce qui rend difficile l’extraction des informations cosmologiques réelles.\nL’un des contaminants principaux est la poussière galactique. Cette poussière émet du rayonnement qui ajoute un bruit significatif au CMB, affectant particulièrement les mesures de polarisation.\nNEXT\nUn autre contaminant majeur est la radiation synchrotron. Elle est produite par des électrons en spirale dans les champs magnétiques de notre galaxie, ce qui vient encore plus brouiller le signal cosmologique que l’on souhaite observer.\nAFTER\nPour pouvoir extraire une valeur fiable du rapport \\(r\\), il est crucial de séparer ou de “démixer” ces composants. Le signal du CMB est mêlé à diverses émissions parasites.\nIl existe différentes méthodes pour cela, principalement des méthodes aveugles comme SMICA, qui fonctionnent sans connaissances préalables des avant-plans, et des méthodes paramétriques comme FGbuster, qui reposent sur la modélisation explicite des avant-plans.\nDans cette présentation, nous allons nous concentrer sur les méthodes paramétriques. Celles-ci nous permettent d’utiliser des modèles pour les avant-plans et d’améliorer la précision du processus de séparation.\n\n\nCredit: Wassim Kabalan"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#on-going-development-of-parametric-component-separation-within-the-furax-framework",
    "href": "2024-cmb-france-6/index.html#on-going-development-of-parametric-component-separation-within-the-furax-framework",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "On-going development of parametric component separation within the FURAX framework",
    "text": "On-going development of parametric component separation within the FURAX framework\n\n\nDoes everything fgbuster does but “better”\n\nUses FURAX linear algebra operators to efficiently represent the mixing matrix\nIs written in JAX, is hardware accelerated\nProvides easy access to gradients\n\n\n\n\n\n\n\n\n\nBeyond fgbuster\n\nAutomatic cluster detection for spectral index parameters\nFlexible likelihood model (can be extended to include more components and different objective functions)\n\n\n\n\n\n\n\n\n\n\nCredit: Wassim Kabalan"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#on-going-development-of-parametric-component-separation-within-the-furax-framework-1",
    "href": "2024-cmb-france-6/index.html#on-going-development-of-parametric-component-separation-within-the-furax-framework-1",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "On-going development of parametric component separation within the FURAX framework",
    "text": "On-going development of parametric component separation within the FURAX framework\n\n\n\n\nCreating a Mixing Matrix Operator for SED evaluation\nfrom furax.seds import \\\n  CMBOperator,DustOperator, SynchrotronOperator\n\ndef make_A(TEMP_D , BETA_D , BETA_S):\n  cmb = CMBOperator(nu, in_structure)\n  dust = DustOperator(nu , TEMP_D , BETA_D)\n  synchrotron = SynchrotronOperator(nu , BETA_S)\n\n  mixed_sed = BlockRowOperator({\n          'cmb': cmb,\n          'dust': dust,\n          'synchrotron': synchrotron,\n      })\n  return mixed_sed\n\n\n\nTrivial construction of a spectral likelihood functions\nimport jax\n\n@jax.jit\ndef negative_log_prob(params, d):\n  A = make_A(params['TEMP_D'], \n             params['BETA_D'], \n             params['BETA_S'])\n\n  x = (A.T @ invN)(d)\n  l = jax.tree.map(lambda a, b: a @ b, x, (A.T @ invN @ A).I(x))\\\n                       S\n  summed_log_prob = jax.tree.reduce(operator.add, l)\n\n  return -summed_log_prob\n\n\n\n\n\n\n\nEasy to evaluate and extend\n\n\n\nThe likelihood function is readily available and can be easily extended to include more components or different objective functions.\nEasy access to gradients and hessians for optimization.\n\n\n\n\n\nCredit: Wassim Kabalan"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#atmosphere-decontamination-using-time-domain-component-separation",
    "href": "2024-cmb-france-6/index.html#atmosphere-decontamination-using-time-domain-component-separation",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Atmosphere Decontamination Using Time-Domain Component Separation",
    "text": "Atmosphere Decontamination Using Time-Domain Component Separation\nScience Goal\nFor the Simons Observatory, characterize the observed atmospheric template from the recorded time-ordered data to separate the atmosphere from the sky signal we are after.\n\n\n\n\n\n\n\nData Model\n\\[\nd_{\\text{atm}} = \\mathbf{A}(\\text{PWV}) \\mathbf{P}(w_x, w_y) s_{\\text{atm}} + n\n\\]\n\n\n\nModel Parameters\n\n\n\nWind velocity: \\(\\vec{w} = (w_x, w_y)\\)\nPrecipitable Water Vapour (PWV): ~Amplitude of atmospheric fluctuations.\nEstimate parameters by minimizing the spectral likelihood.\n\n\n\n\nAtmospheric time-ordered data recorded by our telescope at two frequencies: \\(d_{\\text{atm}}\\)\nMixing matrix \\(\\mathbf{A} =\n\\begin{bmatrix}\n  a(\\text{PWV}_{1}) & 0 \\\\\n  0 & a(\\text{PWV}_{2})\n\\end{bmatrix}\\)\nPointing matrix \\(\\mathbf{P} =\n\\begin{bmatrix}\n  P_{1} \\\\\n  P_{2}\n\\end{bmatrix}\\)\nAtmospheric template: \\(s_{\\text{atm}}\\)\nNoise: \\(n\\), of covariance matrix \\(\\mathbf{N} =\n\\begin{bmatrix}\n  \\sigma_{1}^{2} & 0 \\\\\n  0 & \\sigma_{2}^{2}\n\\end{bmatrix}\\)\n\nSpectral Likelihood\n\\[\n\\boxed{\n\\langle \\delta \\mathcal{S}_\\text{spec}(w_x, w_y, \\text{PWV} \\mid \\vec{d}_{\\text{atm}}) \\rangle\n= \\vec{d}_{\\text{atm}}^\\top \\cdot \\mathbf{AP}\n\\Big[ (\\mathbf{AP})^\\top \\mathbf{N}^{-1} (\\mathbf{AP}) \\Big]^{-1}\n(\\mathbf{AP})^\\top \\mathbf{N}^{-1} d_{\\text{atm}}\n}\n\\]\n\n\nCredit: Amalia Villarrubia Aguilar"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#atmosphere-decontamination-using-time-domain-component-separation-1",
    "href": "2024-cmb-france-6/index.html#atmosphere-decontamination-using-time-domain-component-separation-1",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Atmosphere Decontamination Using Time-Domain Component Separation",
    "text": "Atmosphere Decontamination Using Time-Domain Component Separation\nSpectral likelihood computation using FURAX\ndef average_spectral_likelihood_noise(d_atm, w_vec, PWV):\n    # POINTING matrix (shape: (n_detectors * N_obs * n_freq) x N_pix)\n    P_single_freq = pointing_matrix_single_freq(detector_pointings_t, t_obs, n_detectors, z_atm, d_pix_sim, N_pix_sim, w_vec)\n    P = BlockColumnOperator({‘93’: P_single_freq, ‘145’: P_single_freq})\n    # MIXING matrix: (shape: (n_detectors * N_obs * n_freq) x (n_detectors * N_obs * n_freq))\n    A_block_structure = StokesIPyTree.structure_for((n_detectors,N_obs))\n    A_93 = HomothetyOperator(atm_emission(PWV, mu_93)/atm_emission(PWV, mu_93), in_structure=A_block_structure)\n    A_145 = HomothetyOperator(atm_emission(PWV, mu_145)/atm_emission(PWV, mu_93), in_structure=A_block_structure)\n    A = BlockDiagonalOperator({‘93’: A_93, ‘145’: A_145})\n    # COMPOSITION matrix: mixing matrix @ pointing matrix (shape: (n_detectors * N_obs * n_freq) x N_pix)\n    C = A @ P\n    # NOISE covariance matrix (shape: (n_det x N_obs x n_freq) x (n_det x N_obs x n_freq))\n    N_block_structure = StokesIPyTree.structure_for((n_detectors,N_obs))\n    N_93 = HomothetyOperator(noise_variance_93, in_structure=N_block_structure)\n    N_145 = HomothetyOperator(noise_variance_145, in_structure=N_block_structure)\n    N = BlockDiagonalOperator({‘93’: N_93, ‘145’: N_145})\n    # Spectral likelihood computation:\n    core_op = (C.T @ N.I @ C).I\n    full_op = N.I @ C @ core_op @ C.T @ N.I\n    S = - StokesIPyTree(d_atm) @ StokesIPyTree(full_op(d_atm))\n    return S\n\n\n\nEasily extensible\nEasy access to gradients\n\n\n\n\nCredit: Amalia Villarrubia Aguilar"
  },
  {
    "objectID": "2024-cmb-france-6/index.html#atmosphere-decontamination-using-time-domain-component-separation-2",
    "href": "2024-cmb-france-6/index.html#atmosphere-decontamination-using-time-domain-component-separation-2",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Atmosphere Decontamination Using Time-Domain Component Separation",
    "text": "Atmosphere Decontamination Using Time-Domain Component Separation\n\nSpectral likelihood minimization\n\n\n\n\n\nSpectral likelihood gridding\n\n\n\n \n\n\nGridding process\n\n\n➜ This spectral likelihood is minimised through gridding: we compute \\(\\langle \\delta \\mathcal{S}_\\text{spec}(w_x, w_y \\mid \\text{PWV}_{\\text{sim}}) \\rangle\\)\nfor 22,500 different combinations of \\((w_x, w_y)\\).\n\n\n\n\nCredit: Amalia Villarrubia Aguilar"
  }
]